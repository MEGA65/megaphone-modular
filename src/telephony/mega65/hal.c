#include "includes.h"

unsigned char tof_r;

extern const unsigned char __stack; 

#ifdef WITH_BACKTRACE
#include "function_table.c"
#endif

unsigned char mountd81disk0(char *filename);
unsigned char mountd81disk1(char *filename);

// Generated by function_table.py
extern const uint8_t __wp_regs[9];
  
void hal_init(void) {

  // Write protect text (code) and rodata segments  
  lcopy((uint16_t)&__wp_regs[0],0xffd5000L,9);
}

char to_hex(unsigned char v)
{
  v&=0xf;
  if (v<0xa) return v+'0';
  if (v>0xf) return 0;
  return 'A'+(v-0xa);
}

unsigned char de_bcd(unsigned char in)
{
  return (in &0xf) + (in>>4)*10;  
}

unsigned long mega65_bcddate(void)
{
  // Format is 32-bit packed time.

  // Naive would be:
  // YEAR  = 16 bits BCD!
  // MONTH = 8 bits BCD!
  // DAY   = 8 bits BCD!

  unsigned int year;
  unsigned char month;
  unsigned char day;

  year = 0x2000 + lpeek(0xffd7115L);
  month = lpeek(0xffd7114L);
  day = lpeek(0xffd7113L);

  return (((unsigned long)year)<<16) + (month << 8) + day;
}

unsigned long mega65_bcdtime(void)
{
  // Format is 32-bit BCD packed time (24 hour time)
  return + (((unsigned long)(lpeek(0xffd7112L)&0x7f))<<16) + (lpeek(0xffd7111L)<<8) + lpeek(0xffd7110L);
}


char write_sector(unsigned char drive_id, unsigned char track, unsigned char sector)
{

  // Select FDC rather than SD card sector buffer
  POKE(0xD689L,PEEK(0xD689L)&0x7f);
  
  // Cancel any previous command
  POKE(0xD081L,0x00);

  // Reset FDC buffers
  POKE(0xD081L, 0x01);
  
  // Fail if BUSY flag already set
  if (PEEK(0xD082L) & 0x80) return 2;
  
  // Select and start drive 
  POKE(0xD080L,
       0x60 + // Motor, select
       ((sector>10)?0x00:0x08) // Side select based on sector number
       );
  
  // XXX If the motor was previously off, we should give it some time to spin up for real drives.
  // XXX Seek to the physical track for real drives.
  
  // Specify track, sector and side bytes for FDC to look for (note that physical
  // side selection happens above).

  // Physical tracks are 0-79 for logical tracks 1-80
  POKE(0xD084L,track-1);

  // Physical sector numbers start at 1, not 0, and are 1-10 on each side.
  if (sector>10) {
    POKE(0xD085L,1+sector-10);
    POKE(0xD086L,0x01); // reverse side
  } else {
    POKE(0xD085L,1+sector);
    POKE(0xD086L,0x00); // front side
  }

  // Buffered sector write
  POKE(0xD081L,0x80);

  // Wait for BUSY to clear.
  // if RNF set, then it failed. If clear, then it was fine.
  while(PEEK(0xD082L) & 0x80) continue;

  if (PEEK(0xD082L) & 0x10) return 1;
  
  return 0;
}

char read_sector(unsigned char drive_id, unsigned char track, unsigned char sector)
{
  /*
    Simple FDC sector read routine.
    XXX - We should make sure we turn the motor on to work with real drives.
    But for now, we are just focussing on D81 disk images, on the basis that
    the telephony software _really_ isn't designed for you to operate your phone
    with a deck of floppies.
   */

  // Select FDC rather than SD card sector buffer
  POKE(0xD689L,PEEK(0xD689L)&0x7f);
  
  // Cancel any previous command
  POKE(0xD081L,0x00);

  // Reset FDC buffers
  POKE(0xD081L, 0x01);
  
  // Fail if BUSY flag already set
  if (PEEK(0xD082L) & 0x80) return 2;
  
  // Select and start drive 
  POKE(0xD080L,
       0x60 + // Motor, select
       ((sector>10)?0x00:0x08) // Side select based on sector number
       );
  
  // XXX If the motor was previously off, we should give it some time to spin up for real drives.
  // XXX Seek to the physical track for real drives.
  
  // Specify track, sector and side bytes for FDC to look for (note that physical
  // side selection happens above).

  // Physical tracks are 0-79 for logical tracks 1-80
  POKE(0xD084L,track-1);

  // Physical sector numbers start at 1, not 0, and are 1-10 on each side.
  if (sector>10) {
    POKE(0xD085L,1+sector-10);
    POKE(0xD086L,0x01); // reverse side
  } else {
    POKE(0xD085L,1+sector);
    POKE(0xD086L,0x00); // front side
  }

  // Buffered sector read
  POKE(0xD081L,0x40);

  // Wait for BUSY to clear.
  // if RNF set, then it failed. If clear, then it was fine.
  while(PEEK(0xD082L) & 0x80) continue;

  if (PEEK(0xD082L) & 0x10) return 1;

  // Sector read correctly, and is in the sector buffer,
  // which is where SECTOR_BUFFER_ADDRESS points.
  return 0;
}

char mount_d81(char *filename, unsigned char drive_id)
{
  unsigned char r;
  switch(drive_id) {
  case 0: r=mountd81disk0(filename); break;
  case 1: r=mountd81disk1(filename); break;
  default: return 1;
  }

  if (r==1) {
    return 0;
  } else {
    fail(r);
    return 2;
  }
  
}

char create_d81(char *filename)
{
  return 1;
}

char mega65_mkdir(char *dir)
{
  return 1;
}

char mega65_cdroot(void)
{
  // XXX - Doesn't allow use of different partitions
  chdirroot(0);
  // XXX - chddirroot()'s HYPPO call lacks failure semantics, and doesn't set return value.
  // So we have to assume it succeeded.
  return 0;
}

char mega65_chdir(char *dir)
{
  return chdir(dir);
}

__attribute__((no_instrument_function))
void mega65_uart_print(const char *s)
{  
  while(*s) {
    asm volatile (
        "sta $D643\n\t"   // write A to the trap register
        "clv"             // must be the very next instruction
        :
        : "a"(*s) // put 'error_code' into A before the block
        : "v", "memory"   // CLV changes V; 'memory' blocks reordering across the I/O write
    );

    // Wait a bit between chars
    for(int n=0;n<2;n++) {
      asm volatile(
		   "ldx $D012\n"
		   "1:\n"
		   "cpx $D012\n"
		   "beq 1b\n"
		   :
		   :
		   : "x"   // X is clobbered
		   );
    }
    
    s++;
  }

}

__attribute__((no_instrument_function))
void mega65_uart_printhex(const unsigned char v)
{
  char hex_str[3];

  hex_str[0]=to_hex(v>>4);
  hex_str[1]=to_hex(v&0xf);
  hex_str[2]=0;
  mega65_uart_print(&hex_str[0]);
}

__attribute__((no_instrument_function))
void mega65_uart_printptr(const void *v)
{
  mega65_uart_print("0x");
  mega65_uart_printhex(((unsigned int)v)>>8);
  mega65_uart_printhex(((unsigned int)v));
}

__attribute__((no_instrument_function))
void mega65_uart_printhex16(const uint16_t v)
{
  mega65_uart_print("0x");
  mega65_uart_printhex(((unsigned int)v)>>8);
  mega65_uart_printhex(((unsigned int)v));
}

#ifdef WITH_BACKTRACE

__attribute__((no_instrument_function))
void mega65_fail(const char *file, const char *function, const char *line, unsigned char error_code)
{
  mega65_uart_print(file);

  mega65_uart_print(":");

  mega65_uart_print(line);
  mega65_uart_print(":");
  mega65_uart_print(function);
  mega65_uart_print("():0x");

  mega65_uart_printhex(error_code);
  mega65_uart_print("\n\r");

  dump_backtrace();

  uint8_t old_bg = PEEK(0xD021);
  while(PEEK(0xD610)) POKE(0xD610,0);
  while(!PEEK(0xD610)) POKE(0xD021,PEEK(0xD012));
  POKE(0xD021,old_bg);
  
}

/*
  Stack back-trace facility to help debug error locations.

*/

#define MAX_BT 32
struct frame { const void *site, *stack_pointer; };
static struct frame callstack[MAX_BT];
static uint8_t depth, sp;

__attribute__((no_instrument_function))
void __cyg_profile_func_enter(void) {
  if (depth>=MAX_BT) depth--;

  uint8_t z;
  __asm__ volatile("tza"         // Z -> A
		   : "=a"(z)      // output: A goes into 'z'
		   :              // no inputs
		   : "cc");       // flags changed by TZA
  if (z) {
    POKE(0xD02f,'G');
    POKE(0xD02f,'S');
    mega65_uart_print("Z != $00\n\r");    
    dump_backtrace();
    while(1) continue;
  }
  
  // Get SPL into sp variable declared above.
  __asm__ volatile ("tsx" : "=x"(sp));
  // Now convert that in
  const uint8_t *stack_pointer = (void *)(0x0100 + sp);
  
  void *call_site = (void *)((*((uint16_t *)&stack_pointer[1])) - 1);
  
  callstack[depth] = (struct frame){ call_site, &__stack };
  depth++;
}

__attribute__((no_instrument_function))
void __cyg_profile_func_exit(void) {
  if (depth) --depth; // simple, assumes well-nested calls
}

__attribute__((no_instrument_function))
void dump_backtrace(void) {
  // For each frame, either:
  //  - print raw addresses, or
  //  - call your on-target addr2line() to print file:line + function

  mega65_uart_print("Backtrace (most recent call first):\n\r");
  unsigned char d= depth-1;

  for(unsigned char d = depth-1;d!=0xff;d--) {
    mega65_uart_print("[");
    mega65_uart_printhex(d);
    mega65_uart_print("] ");

    // Find function in table
    unsigned int func_num = 0;
    while(func_num<(function_table_count-1) && function_table[func_num+1].addr < (uint16_t)callstack[d].site)
      func_num++;

    // Display offset from function
    mega65_uart_printptr(callstack[d].site);
    mega65_uart_print(" ");
    mega65_uart_print(function_table[func_num].function);
    mega65_uart_print("+");
    mega65_uart_printptr((void*)((uint16_t)callstack[d].site - function_table[func_num].addr));

    // Show stack pointer
    mega65_uart_print(", SP=");
    mega65_uart_printptr(callstack[d].stack_pointer);
    mega65_uart_print("\n\r");
  } 
}

void nmi_catcher(void)
{
    uint8_t a,x,y,p,s, pcl, pch;
    uint16_t pc_after, brk_addr, sp_before;

    // Save A, X, Y; read S, saved PCL/PCH/P from the stack frame
    __asm__ volatile ("tsx\n\ttxa" : "=a"(s) : : "x");          // get S (post-push)
    
    __asm__ volatile ("lda $0103,x" : "=a"(a)   : : "x","memory");
    __asm__ volatile ("lda $0102,x" : "=a"(x)   : : "x","memory");
    __asm__ volatile ("lda $0101,x" : "=a"(y)   : : "x","memory");
    __asm__ volatile ("lda $0104,x" : "=a"(p)   : : "x","memory");
    __asm__ volatile ("lda $0105,x" : "=a"(pcl) : : "x","memory");
    __asm__ volatile ("lda $0106,x" : "=a"(pch) : : "x","memory");       
    
    pc_after  = (uint16_t)((pch << 8) | pcl);
    brk_addr  = pc_after - 2;             // BRK opcode address
    sp_before = (uint8_t)(s + 3 + 3);         // SP value before the CPU's pushes

    mega65_uart_print(">>>\r\n\n>>> NMI/BRK triggered.\r\n");

    mega65_uart_print(" A:"); mega65_uart_printhex(a);
    mega65_uart_print(" X:"); mega65_uart_printhex(x);
    mega65_uart_print(" Y:"); mega65_uart_printhex(y);
    mega65_uart_print(" P:"); mega65_uart_printhex(p);
    mega65_uart_print(" S:"); mega65_uart_printhex(s);
    mega65_uart_print("\r\n");

    // Find function in table
    unsigned int func_num = 0;
    while(func_num<(function_table_count-1) && function_table[func_num+1].addr < brk_addr)
      func_num++;

    // Display offset from function
    mega65_uart_print("  BRK source @ ");

    mega65_uart_printhex16(brk_addr);
    mega65_uart_print(" ");
    mega65_uart_print(function_table[func_num].function);
    mega65_uart_print("+");
    mega65_uart_printptr((void*)(brk_addr - function_table[func_num].addr));

    mega65_uart_print("\r\n");

    dump_backtrace();
    while (1) { /* halt */ }
}

#endif

