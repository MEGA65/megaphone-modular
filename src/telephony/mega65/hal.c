#include "includes.h"

unsigned char tof_r;

extern const unsigned char __stack; 

#ifdef WITH_BACKTRACE
#include "function_table.c"
#endif

#define MAX_PATH_LEN 256
char cwd[MAX_PATH_LEN];
int cwd_len = 0;

char drive0file[MAX_PATH_LEN]="<not mounted>";
char drive1file[MAX_PATH_LEN]="<not mounted>";

unsigned char mountd81disk0(char *filename);
unsigned char mountd81disk1(char *filename);

// Generated by function_table.py
extern const uint8_t __wp_regs[9];
  
void hal_init(void) {

  // Write protect text (code) and rodata segments  
  lcopy((uint16_t)&__wp_regs[0],0xffd5000L,9);

  // Flush hardware keyboard input buffer
  while(PEEK(0xD610)) POKE(0xD610,0);
}

unsigned int mega65_strlen(char *s)
{
  uint16_t len=0;
  while (*s) {
    if (len==0xffff) break;
    len++; s++;
  }
  return len;
}

char to_hex(unsigned char v)
{
  v&=0xf;
  if (v<0xa) return v+'0';
  if (v>0xf) return 0;
  return 'A'+(v-0xa);
}

unsigned char de_bcd(unsigned char in)
{
  return (in &0xf) + (in>>4)*10;  
}

unsigned long mega65_bcddate(void)
{
  // Format is 32-bit packed time.

  // Naive would be:
  // YEAR  = 16 bits BCD!
  // MONTH = 8 bits BCD!
  // DAY   = 8 bits BCD!

  unsigned int year;
  unsigned char month;
  unsigned char day;

  year = 0x2000 + lpeek(0xffd7115L);
  month = lpeek(0xffd7114L);
  day = lpeek(0xffd7113L);

  return (((unsigned long)year)<<16) + (month << 8) + day;
}

unsigned long mega65_bcdtime(void)
{
  // Format is 32-bit BCD packed time (24 hour time)
  return + (((unsigned long)(lpeek(0xffd7112L)&0x7f))<<16) + (lpeek(0xffd7111L)<<8) + lpeek(0xffd7110L);
}


char write_sector(unsigned char drive_id, unsigned char track, unsigned char sector)
{

#if 0
  mega65_uart_print("Image in drive ");
  mega65_uart_printhex(drive_id);
  mega65_uart_print(" is ");
  mega65_uart_print(cwd);
  switch(drive_id) {
  case 0:  mega65_uart_print(drive0file); break;
  case 1:  mega65_uart_print(drive1file); break;
  default: mega65_uart_print("<illegal drive>"); break;
  }
  mega65_uart_print("\r\n");
  
  dump_bytes("Writing sector data beginning with", SECTOR_BUFFER_ADDRESS,16);
#endif
  
  // Select FDC rather than SD card sector buffer
  POKE(0xD689L,PEEK(0xD689L)&0x7f);
  
  // Cancel any previous command
  POKE(0xD081L,0x00);

  // Reset FDC buffers
  POKE(0xD081L, 0x01);
  
  // Fail if BUSY flag already set
  if (PEEK(0xD082L) & 0x80) return 2;
  
  // Select and start drive 
  POKE(0xD080L,
       drive_id + 
       0x60 + // Motor, select
       ((sector>10)?0x00:0x08) // Side select based on sector number
       );
  
  // XXX If the motor was previously off, we should give it some time to spin up for real drives.
  // XXX Seek to the physical track for real drives.
  
  // Specify track, sector and side bytes for FDC to look for (note that physical
  // side selection happens above).

  // Physical tracks are 0-79 for logical tracks 1-80
  POKE(0xD084L,track-1);

  // Physical sector numbers start at 1, not 0, and are 1-10 on each side.
  if (sector>10) {
    POKE(0xD085L,1+sector-10);
    POKE(0xD086L,0x01); // reverse side
  } else {
    POKE(0xD085L,1+sector);
    POKE(0xD086L,0x00); // front side
  }

  // Buffered sector write
  POKE(0xD081L,0x80);

  // Wait for BUSY to clear.
  // if RNF set, then it failed. If clear, then it was fine.
  while(PEEK(0xD082L) & 0x80) continue;

  if (PEEK(0xD082L) & 0x10) return 1;
  
  return 0;
}

char read_sector(unsigned char drive_id, unsigned char track, unsigned char sector)
{
  /*
    Simple FDC sector read routine.
    XXX - We should make sure we turn the motor on to work with real drives.
    But for now, we are just focussing on D81 disk images, on the basis that
    the telephony software _really_ isn't designed for you to operate your phone
    with a deck of floppies.
   */

  // Select FDC rather than SD card sector buffer
  POKE(0xD689L,PEEK(0xD689L)&0x7f);
  
  // Cancel any previous command
  POKE(0xD081L,0x00);

  // Reset FDC buffers
  POKE(0xD081L, 0x01);
  
  // Fail if BUSY flag already set
  if (PEEK(0xD082L) & 0x80) return 2;
  
  // Select and start drive 
  POKE(0xD080L,
       drive_id +
       0x60 + // Motor, select
       ((sector>10)?0x00:0x08) // Side select based on sector number
       );
  
  // XXX If the motor was previously off, we should give it some time to spin up for real drives.
  // XXX Seek to the physical track for real drives.
  
  // Specify track, sector and side bytes for FDC to look for (note that physical
  // side selection happens above).

  // Physical tracks are 0-79 for logical tracks 1-80
  POKE(0xD084L,track-1);

  // Physical sector numbers start at 1, not 0, and are 1-10 on each side.
  if (sector>10) {
    POKE(0xD085L,1+sector-10);
    POKE(0xD086L,0x01); // reverse side
  } else {
    POKE(0xD085L,1+sector);
    POKE(0xD086L,0x00); // front side
  }

  // Buffered sector read
  POKE(0xD081L,0x40);

  // Wait for BUSY to clear.
  // if RNF set, then it failed. If clear, then it was fine.
  while(PEEK(0xD082L) & 0x80) continue;

  if (PEEK(0xD082L) & 0x10) return 1;

  // Sector read correctly, and is in the sector buffer,
  // which is where SECTOR_BUFFER_ADDRESS points.
  return 0;
}

char mount_d81(char *filename, unsigned char drive_id)
{
  unsigned char r;

  if (mega65_strlen(filename)>=MAX_PATH_LEN) { fail(3); return 3; }
  
  switch(drive_id) {
  case 0:
    r=mountd81disk0(filename);
    if (r==1) {
      lcopy((unsigned long)filename,(unsigned long) drive0file, mega65_strlen(filename)+1);
    }
    break;
  case 1:
    r=mountd81disk1(filename);
    if (r==1) {
      lcopy((unsigned long)filename,(unsigned long) drive1file, mega65_strlen(filename)+1);
    }
    break;
  default:
    fail(1);
    return 1;
  }

  if (r==1) {
    return 0;
  } else {
    fail(r);
    return 2; 
  }
  
}

char create_d81(char *filename)
{
  mega65_uart_print("WARNING: create_d81(\"");
  mega65_uart_print(filename);
  mega65_uart_print("\") not implemented.\r\n");
  return 1;
}

char mega65_mkdir(char *dir)
{
  mega65_uart_print("WARNING: mega65_mkdir(\"");
  mega65_uart_print(dir);
  mega65_uart_print("\") not implemented.\r\n");
  return 1;
}

char mega65_cdroot(void)
{
  // XXX - Doesn't allow use of different partitions
  chdirroot(0);
  // XXX - chddirroot()'s HYPPO call lacks failure semantics, and doesn't set return value.  
  // So we have to assume it succeeded.

  cwd[0]='/'; cwd[1]=0;
  cwd_len=1;
  
  return 0;
}

char mega65_chdir(char *dir)
{
  // Abort if path too long
  if ( (mega65_strlen(dir) + cwd_len) >= (MAX_PATH_LEN - 2)) { fail(1); return 1; }
  
  uint8_t r = chdir(dir);
  if (!r) {
    lcopy((unsigned long)dir, (unsigned long)&cwd[cwd_len],mega65_strlen(dir)+1);
    cwd_len+=mega65_strlen(dir);
    cwd[cwd_len++]='/';
    cwd[cwd_len]=0;
  }
  return r;
}

__attribute__((no_instrument_function))
void mega65_uart_print(const char *s)
{  
  while(*s) {
    asm volatile (
        "sta $D643\n\t"   // write A to the trap register
        "clv"             // must be the very next instruction
        :
        : "a"(*s) // put 'error_code' into A before the block
        : "v", "memory"   // CLV changes V; 'memory' blocks reordering across the I/O write
    );

    // Wait a bit between chars
    for(int n=0;n<2;n++) {
      asm volatile(
		   "ldx $D012\n"
		   "1:\n"
		   "cpx $D012\n"
		   "beq 1b\n"
		   :
		   :
		   : "x"   // X is clobbered
		   );
    }
    
    s++;
  }

}

__attribute__((no_instrument_function))
void mega65_uart_printhex(const unsigned char v)
{
  char hex_str[3];

  hex_str[0]=to_hex(v>>4);
  hex_str[1]=to_hex(v&0xf);
  hex_str[2]=0;
  mega65_uart_print(&hex_str[0]);
}

__attribute__((no_instrument_function))
void mega65_uart_printptr(const void *v)
{
  mega65_uart_print("0x");
  mega65_uart_printhex(((unsigned int)v)>>8);
  mega65_uart_printhex(((unsigned int)v));
}

__attribute__((no_instrument_function))
void mega65_uart_printhex16(const uint16_t v)
{
  mega65_uart_printhex(((unsigned int)v)>>8);
  mega65_uart_printhex(((unsigned int)v));
}

#ifdef WITH_BACKTRACE

__attribute__((no_instrument_function))
void mega65_fail(const char *file, const char *function, const char *line, unsigned char error_code)
{
  mega65_uart_print(file);

  mega65_uart_print(":");

  mega65_uart_print(line);
  mega65_uart_print(":");
  mega65_uart_print(function);
  mega65_uart_print("():0x");

  mega65_uart_printhex(error_code);
  mega65_uart_print("\n\r");

  dump_backtrace();

  uint8_t old_bg = PEEK(0xD021);
  while(PEEK(0xD610)) POKE(0xD610,0);
  while(!PEEK(0xD610)) POKE(0xD021,PEEK(0xD012));
  POKE(0xD021,old_bg);
  
}

/*
  Stack back-trace facility to help debug error locations.

*/

#define MAX_BT 32
struct frame { const void *site, *stack_pointer; };
static struct frame callstack[MAX_BT];
static uint8_t depth, sp;

__attribute__((no_instrument_function))
void __cyg_profile_func_enter(void) {
  if (depth>=MAX_BT) depth--;

  uint8_t z;
  __asm__ volatile("tza"         // Z -> A
		   : "=a"(z)      // output: A goes into 'z'
		   :              // no inputs
		   : "cc");       // flags changed by TZA
  if (z) {
    POKE(0xD02f,'G');
    POKE(0xD02f,'S');
    mega65_uart_print("Z != $00\n\r");    
    dump_backtrace();
    while(1) continue;
  }
  
  // Get SPL into sp variable declared above.
  __asm__ volatile ("tsx" : "=x"(sp));
  // Now convert that in
  const uint8_t *stack_pointer = (void *)(0x0100 + sp);
  
  void *call_site = (void *)((*((uint16_t *)&stack_pointer[1])) - 2);
  
  callstack[depth] = (struct frame){ call_site, &__stack };
  depth++;
}

__attribute__((no_instrument_function))
void __cyg_profile_func_exit(void) {
  if (depth) --depth; // simple, assumes well-nested calls
}

__attribute__((no_instrument_function))
void dump_backtrace(void) {
  // For each frame, either:
  //  - print raw addresses, or
  //  - call your on-target addr2line() to print file:line + function

  mega65_uart_print("Backtrace (most recent call first):\n\r");

  for(unsigned char d = depth-1;d!=0xff;d--) {
    mega65_uart_print("[");
    mega65_uart_printhex(d);
    mega65_uart_print("] ");

    // Find function in table
    unsigned int func_num = 0;
    while((func_num+1)<function_table_count
	  && function_table[func_num+1].addr < (uint16_t)callstack[d].site)
      func_num++;

    // Display offset from function
    mega65_uart_printptr(callstack[d].site);
    mega65_uart_print(" ");
    mega65_uart_print(function_table[func_num].function);
    mega65_uart_print("+");
    mega65_uart_printptr((void*)((uint16_t)callstack[d].site - function_table[func_num].addr));

    // Show stack pointer
    mega65_uart_print(", SP=");
    mega65_uart_printptr(callstack[d].stack_pointer);
    mega65_uart_print("\n\r");
  } 
}

void nmi_catcher(void)
{
    uint8_t a,x,y,p,s, pcl, pch;
    uint16_t pc_after, brk_addr;

    // Save A, X, Y; read S, saved PCL/PCH/P from the stack frame
    __asm__ volatile ("tsx\n\ttxa" : "=a"(s) : : "x");          // get S (post-push)
    
    __asm__ volatile ("lda $0103,x" : "=a"(a)   : : "x","memory");
    __asm__ volatile ("lda $0102,x" : "=a"(x)   : : "x","memory");
    __asm__ volatile ("lda $0101,x" : "=a"(y)   : : "x","memory");
    __asm__ volatile ("lda $0104,x" : "=a"(p)   : : "x","memory");
    __asm__ volatile ("lda $0105,x" : "=a"(pcl) : : "x","memory");
    __asm__ volatile ("lda $0106,x" : "=a"(pch) : : "x","memory");       
    
    pc_after  = (uint16_t)((pch << 8) | pcl);
    brk_addr  = pc_after - 2;             // BRK opcode address

    mega65_uart_print(">>>\r\n\n>>> NMI/BRK triggered.\r\n");

    mega65_uart_print(" A:"); mega65_uart_printhex(a);
    mega65_uart_print(" X:"); mega65_uart_printhex(x);
    mega65_uart_print(" Y:"); mega65_uart_printhex(y);
    mega65_uart_print(" P:"); mega65_uart_printhex(p);
    mega65_uart_print(" S:"); mega65_uart_printhex(s);
    mega65_uart_print("\r\n");

    // Find function in table
    unsigned int func_num = 0;
    while(func_num<(function_table_count-1) && function_table[func_num+1].addr < brk_addr)
      func_num++;

    // Display offset from function
    mega65_uart_print("  BRK source @ ");

    mega65_uart_printhex16(brk_addr);
    mega65_uart_print(" ");
    mega65_uart_print(function_table[func_num].function);
    mega65_uart_print("+");
    mega65_uart_printptr((void*)(brk_addr - function_table[func_num].addr));

    mega65_uart_print("\r\n");

    dump_backtrace();
    while (1) { /* halt */ }
}

unsigned char as_printable(unsigned char c)
{
  if (c<' ') return '.';
  if (c>=0x7e) return '.';
  return c;
}

void dump_bytes(char *msg, unsigned long d_in, int len)
{  
  mega65_uart_print("DEBUG: ");
  mega65_uart_print(msg);
  mega65_uart_print("\r\n");
  for(int i=0;i<len;i+=16) {
    mega65_uart_printhex16(i);
    mega65_uart_print(": ");
    for(int j=0;j<16;j++) {
      if ((i+j)<len) {
	mega65_uart_printhex(lpeek(d_in+i+j));
	mega65_uart_print(" ");
      } else mega65_uart_print("   ");
    }
    mega65_uart_print("  ");
    for(int j=0;j<16;j++) {
      if ((i+j)<len) {
	char cc[2];
	cc[0]=as_printable(lpeek(d_in+i+j));
	cc[1]=0;
	mega65_uart_print(cc);
      } 
    }
    mega65_uart_print("\r\n");
  }
}


#endif


